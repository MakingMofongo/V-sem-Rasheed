{
	"nodes":[
		{"id":"327b3cf255250ad1","type":"group","x":-306,"y":35,"width":290,"height":325,"color":"1","label":"1st Priority"},
		{"id":"b703527f4d45587a","type":"file","file":"PDFs/CSM SYLLABUS.pdf","x":280,"y":-2480,"width":868,"height":1000},
		{"id":"6bb9a144474fc0ce","type":"file","file":"PDFs/compiler design notes1,2,3,4.pdf","x":-1020,"y":-1840,"width":1157,"height":560,"color":"4"},
		{"id":"62c28d79a8202e78","type":"file","file":"PDFs/unit-1-notess.pdf","x":1000,"y":-990,"width":400,"height":400},
		{"id":"94550d673743ef6b","type":"text","text":"# 2.Write a short note on  syntax tree, parameter passing with examples","x":-2603,"y":-1000,"width":383,"height":195,"color":"4"},
		{"id":"4729e97a348bea4e","type":"file","file":"PDFs/compiler Design COUNTIU=NUE unit 4.5.pdf","x":-2200,"y":-1879,"width":1109,"height":639,"color":"4"},
		{"id":"71275df768c5c3df","type":"text","text":"# 3.Give syenthesized attribute,and inherited attribute,L-attribute  give example.","x":-2603,"y":-760,"width":383,"height":220,"color":"4"},
		{"id":"e13299690518c8b3","type":"text","text":"## From Sir's PDF\n\n1.What is syntax Directed definition\n\n![[Pasted image 20240217203727.png]]\n\n\nand syntax directed translation \n![[Pasted image 20240217203958.png]]\n\nwith examples ...\n","x":-4160,"y":-2876,"width":625,"height":621},
		{"id":"f47c3bd63d7bcf62","type":"text","text":"# 1.What is syntax Directed definition and syntax directed translation with examples\n","x":-3240,"y":-2219,"width":403,"height":239,"color":"4"},
		{"id":"335a3d359cf51a01","type":"text","text":"A syntax tree, also known as a parse tree, is a hierarchical representation of the syntactic structure of a program or expression according to its grammar rules. It visually depicts how the input code is parsed and organized based on its grammar.\n\nIn a syntax tree:\n\n- Nodes represent language constructs such as expressions, statements, or operators.\n- Edges represent relationships between these constructs, typically indicating parent-child relationships.\n\nFor example, consider the expression \"3 * (2 + 4)\" represented as a syntax tree:\n\n```\n      *\n     / \\\n    3   +\n       / \\\n      2   4\n```\n\nParameter passing refers to the mechanism by which arguments are passed to functions or procedures during invocation. There are several methods of parameter passing, including:\n\n1. **Pass by Value**: Copies the value of the actual parameter into the formal parameter. Changes made to the formal parameter do not affect the actual parameter. Example:\n\n```C\nvoid square(int x) {\n    x = x * x;  // Changes to x do not affect the original value outside the function\n}\nint main() {\n    int num = 5;\n    square(num); // num is passed by value\n    // num is still 5 after the function call\n    return 0;\n}\n```\n\n2. **Pass by Reference**: Passes a reference (memory address) of the actual parameter to the formal parameter. Changes made to the formal parameter affect the actual parameter. Example:\n\n```C++\nvoid increment(int& x) {\n    x++;  // Changes to x affect the original value outside the function\n}\nint main() {\n    int num = 5;\n    increment(num); // num is passed by reference\n    // num is now 6 after the function call\n    return 0;\n}\n```\n\n3. **Pass by Pointer**: Passes the address of the actual parameter using pointers. Similar to pass by reference, changes made to the formal parameter affect the actual parameter. Example:\n\n```C++\nvoid decrement(int* x) {\n    (*x)--;  // Changes to *x affect the original value outside the function\n}\nint main() {\n    int num = 5;\n    decrement(&num); // Address of num is passed\n    // num is now 4 after the function call\n    return 0;\n}\n```\n\nSyntax trees are useful in understanding how parameters are passed and manipulated within a program, as they provide a visual representation of the program's structure and execution flow.","x":-4400,"y":-1240,"width":720,"height":763},
		{"id":"c9a1855a5b31a55e","type":"text","text":"## 5. What is type checking,switch statement","x":-2603,"y":-153,"width":383,"height":197,"color":"4"},
		{"id":"53cdcf30d331c445","type":"text","text":"## 4.Take one  SDT  and generate parese tree for one string","x":-2603,"y":-477,"width":383,"height":240,"color":"4"},
		{"id":"91b9b9ae30398e80","type":"text","text":"Moiz","x":-2680,"y":180,"width":250,"height":60},
		{"id":"3ed26694ed753271","type":"text","text":"## Synthesized , inherited attributes and L-attributes.\n\n1. **Synthesized Attribute**: Synthesized attributes are attributes whose values are computed at a node based on the values of its children in the parse tree. These values are synthesized or computed bottom-up during tree traversal.\n\nExample:\nConsider a grammar for arithmetic expressions:\n\n```\nE -> E + T | T\nT -> T * F | F\nF -> (E) | id\n```\n\nNow, let's define a synthesized attribute `value` for each non-terminal representing the value of the expression:\n\n```\nE -> E1 + T { E.value = E1.value + T.value; }\n   | T { E.value = T.value; }\nT -> T1 * F { T.value = T1.value * F.value; }\n   | F { T.value = F.value; }\nF -> (E) { F.value = E.value; }\n   | id { F.value = id.value; }\n```\n\nIn this example, `value` is synthesized because it's computed based on the values of its children in the parse tree.\n\n2. **Inherited Attribute**: Inherited attributes are attributes that are passed down from parent nodes to their children during tree traversal. These attributes are computed top-down during parsing.\n\nExample:\nConsider a grammar for a simple if-else statement:\n\n```\nS -> if (E) S1 else S2 | other\n```\n\nNow, let's define an inherited attribute `hasElse` to indicate whether an if statement has an else clause:\n\n```\nS -> if (E) S1 else S2 { S.hasElse = true; }\n   | other { S.hasElse = false; }\n```\n\nIn this example, `hasElse` is inherited because its value is determined at the parent node (`S`), and it's passed down to its children (`S1` and `S2`).\n\n3. **L-attribute**: An L-attribute is a synthesized attribute whose value is computed by traversing the parse tree from left to right and from bottom to top. These attributes can be computed using only attributes from nodes that have been already visited.\n\nExample:\nConsider a grammar for a simple while loop:\n\n```\nS -> while (E) S1\n```\n\nNow, let's define an L-attribute `loopDepth` to indicate the depth of nested while loops:\n\n```\nS -> while (E) S1 { S.loopDepth = S1.loopDepth + 1; }\n   | other { S.loopDepth = 0; }\n```\n\nIn this example, `loopDepth` is an L-attribute because its value is computed bottom-up and left-to-right during tree traversal.\n\nThese concepts are fundamental in attribute grammar, which is often used in syntax-directed translation and semantic analysis during compiler design.","x":-4400,"y":-339,"width":720,"height":765},
		{"id":"0966f6e5949f177e","type":"text","text":"Let's consider a simple syntax-directed translation (SDT) example for arithmetic expressions. We'll define an SDT that generates a parse tree for an expression.\n\nGrammar:\n```\nE -> E + T | T\nT -> T * F | F\nF -> ( E ) | id\n```\n\nSyntax-Directed Translation:\n```\nE -> E1 + T { E.value = E1.value + T.value; }\n   | T { E.value = T.value; }\nT -> T1 * F { T.value = T1.value * F.value; }\n   | F { T.value = F.value; }\nF -> (E) { F.value = E.value; }\n   | id { F.value = id.value; }\n```\n\nLet's generate a parse tree for the expression \"3 * (2 + 4)\" using the SDT:\n\n1. Tokenize the expression:\n```\n3   *   (   2   +   4   )\n```\n\n2. Apply the SDT rules to construct the parse tree:\n\n```\n          E\n         / \\\n        T   +\n       /   / \\\n      F   E   T\n     / |   |   |\n    3  *   (   )\n       |      / \\\n       |     T   F\n       |     |   |\n       |     F   4\n       |     |\n       |     2\n```\n\nIn this parse tree:\n- Each non-terminal corresponds to a grammar rule application.\n- Terminals (tokens) are represented at the leaves of the tree.\n- The value attribute is computed according to the SDT rules.","x":-4400,"y":520,"width":720,"height":640},
		{"id":"c8e2ac1938f361c0","type":"text","text":"Type checking is a process performed by compilers or interpreters to ensure that the types of operands in an expression or statement are compatible with the operations being performed. It verifies that the operations and assignments in a program are semantically meaningful according to the language's type system. Type checking helps catch errors early in the development process and ensures that the program behaves as expected during execution.\n\nFor example, in a statically typed language like Java or C++, type checking verifies that you're not trying to add a string to an integer or assign a value of the wrong type to a variable. In a dynamically typed language like Python, type checking is often performed at runtime, ensuring that operations are only performed on operands of compatible types.\n\nA switch statement is a control flow statement used to select one of many code blocks to be executed based on the value of a variable or expression. It provides a concise way to write multiple if-else-if statements.\n\nSyntax of a switch statement varies slightly between programming languages, but generally, it looks like this in C-like languages:\n\n```c\nswitch (expression) {\n    case value1:\n        // code block 1\n        break;\n    case value2:\n        // code block 2\n        break;\n    ...\n    default:\n        // default code block\n}\n```\n\nHere's how it works:\n- The expression is evaluated.\n- The value of the expression is compared with the values in the case labels.\n- If a match is found, the corresponding code block is executed.\n- If no match is found, the code block under the `default` label is executed (if present).\n- The `break` statement is used to exit the switch statement after executing the corresponding code block. If `break` is omitted, control falls through to the next case label, and subsequent code blocks are executed until a `break` is encountered or the switch statement ends.\n\nSwitch statements are often used when there are multiple conditions to check against the same variable, providing a cleaner and more readable alternative to using multiple if-else statements.","x":-4400,"y":1240,"width":720,"height":666},
		{"id":"d72c9d39b7812473","type":"text","text":"10. what is storage organization","x":-2280,"y":180,"width":303,"height":62},
		{"id":"c74b20207d4c5805","type":"text","text":"CD","x":-286,"y":55,"width":250,"height":60,"color":"4"},
		{"id":"d6a07453d635f1f9","type":"text","text":"AI","x":-8,"y":55,"width":250,"height":60},
		{"id":"11002d409535b6f6","type":"file","file":"cd imp 2.5.docx","x":-1355,"y":45,"width":200,"height":80,"color":"4"},
		{"id":"c0ca81992ad252a0","type":"text","text":"1.What is syntax Directed definition and syntax directed translation with examples\n\n2.write a short note on  syntax tree, parameter passing with examples\n\n3.Give syenthesized attribute,and inherited attribute,L-attribute  give\n\nexample.\n\n4.Take one  SDT  and generate parese tree for one string\n\n5.What is type checking,switch statement\n\n6.Give annotated parse tree and 3-address  code\n\n7.what is peephole optimization\n\n8.what is basic blocks and flow graph\n\n9.What are design issues in code generator\n\n10.what is storage organization","x":-1580,"y":-590,"width":651,"height":502,"color":"4"},
		{"id":"6febd5d87e7d459c","type":"text","text":"9. What are design issues in code generator","x":-2128,"y":-7,"width":277,"height":105},
		{"id":"526ca694044b1cfe","type":"text","text":"WIT","x":-8,"y":160,"width":250,"height":60},
		{"id":"0717a62c6bd43a5e","type":"text","text":"OS","x":-286,"y":160,"width":250,"height":60},
		{"id":"352f46086bea4476","type":"text","text":"SNLP","x":-286,"y":280,"width":250,"height":60,"color":"2"},
		{"id":"6503f9fdad76969c","type":"text","text":"ML for DS","x":-8,"y":280,"width":250,"height":60,"color":"#1523e5"},
		{"id":"30debd7ff6db2ade","type":"file","file":"Important question for Tutorial 3 1.docx","x":242,"y":560,"width":230,"height":165},
		{"id":"846aafdf8311d65c","type":"text","text":"\n\n## Important question for Tutorial\n\n1.      What is linear classification? Explain the concept of decision boundaries and how they relate to linear classifiers.\n\n2.      Discuss the concept of bagging and boosting in ensemble learning. How do they address the problem of overfitting?\n\n3.      What are ensemble classifiers, and how do they differ from individual classifiers? Provide examples of popular ensemble methods.\n\n4.      What is model selection, and why is it important in machine learning? Describe at least two common techniques for model selection.\n\n5.      Define cross-validation and explain why it is used in machine learning. Describe at least two popular methods of cross-validation.\n\n6.      What is probabilistic modeling in the context of machine learning? How does it differ from deterministic modeling?\n\n7.      Discuss at least two common probabilistic models used in machine learning. What are their strengths and weaknesses?\n\n8.      Define topic modeling and discuss its applications in natural language processing (NLP). How does probabilistic inference play a role in topic modeling algorithms such as Latent Dirichlet Allocation (LDA)?\n\n9.      Describe at least two machine learning algorithms commonly used for predicting preterm birth. How do these algorithms utilize probabilistic modeling principles?\n\n10.  Compare and contrast machine learning and statistics. How do they differ in their goals, methodologies, and applications?","x":104,"y":820,"width":507,"height":940},
		{"id":"d878113263c029ee","type":"text","text":"## 1. What is linear classification? Explain the concept of decision boundaries and how they relate to linear classifiers.\n\nLinear classification is a technique in machine learning used to **classify** data into different categories **based on linear decision boundarie**s.\n\nDecision boundaries are the dividing lines or surfaces that **separate different classes** in a dataset. In linear classification, these **decision boundaries are linear**, meaning they can be represented by straight lines or planes in the feature space.\n\nLinear classifiers **aim to find the optimal linear decision boundary** that best separates the data points into their respective classes.","x":810,"y":760,"width":595,"height":380,"color":"1"},
		{"id":"6a68466816480075","type":"text","text":"## 2. Discuss the concept of bagging and boosting in ensemble learning. How do they address the problem of overfitting?\n\nBagging and boosting are both ensemble learning techniques used to improve the performance of machine learning models by combining multiple weak learners.\n\nBagging, which stands for Bootstrap Aggregating, involves training multiple models on different subsets of the training data, where each subset is sampled with replacement. The final prediction is then made by averaging the predictions of all the models (for regression) or taking a majority vote (for classification). Bagging helps to reduce variance and overfitting by averaging out the predictions of multiple models trained on different subsets of data, thereby making the overall prediction more robust.\n\nBoosting, on the other hand, involves training a sequence of weak learners sequentially, where each subsequent learner focuses on the examples that were misclassified by the previous ones. The final prediction is made by combining the predictions of all the weak learners, typically using a weighted sum. Boosting iteratively improves the model's performance by giving more weight to the examples that are harder to classify correctly, thereby reducing bias and improving generalization.","x":1540,"y":760,"width":595,"height":640,"color":"5"},
		{"id":"24a5e7f6bafdfc39","type":"file","file":"Images/WhatsApp Image 2024-02-15 at 13.05.21_b2b8aeb6.jpg","x":-880,"y":460,"width":484,"height":860},
		{"id":"4764d7f5736a45a7","type":"file","file":"Syntax Directed Translation and Definition. GPT + Research.md","x":-3980,"y":-1980,"width":600,"height":576}
	],
	"edges":[
		{"id":"47fde9acda44a61a","fromNode":"352f46086bea4476","fromSide":"bottom","toNode":"24a5e7f6bafdfc39","toSide":"top","color":"2"},
		{"id":"e6d63f9c1029db5e","fromNode":"30debd7ff6db2ade","fromSide":"bottom","toNode":"846aafdf8311d65c","toSide":"top"},
		{"id":"84f6269a08c6bcc9","fromNode":"6503f9fdad76969c","fromSide":"bottom","toNode":"30debd7ff6db2ade","toSide":"top","color":"#192296"},
		{"id":"229bff6a6daf0b71","fromNode":"d6a07453d635f1f9","fromSide":"right","toNode":"62c28d79a8202e78","toSide":"left"},
		{"id":"da5abb483f604ebc","fromNode":"846aafdf8311d65c","fromSide":"right","toNode":"d878113263c029ee","toSide":"left"},
		{"id":"2a0b0c042e52f5e9","fromNode":"846aafdf8311d65c","fromSide":"right","toNode":"6a68466816480075","toSide":"left"},
		{"id":"7edc2c1cf81f95a8","fromNode":"11002d409535b6f6","fromSide":"top","toNode":"c0ca81992ad252a0","toSide":"bottom","color":"4"},
		{"id":"cf30db9b8e02cd19","fromNode":"c74b20207d4c5805","fromSide":"left","toNode":"11002d409535b6f6","toSide":"right","color":"4"},
		{"id":"cb9d16a29157456f","fromNode":"c74b20207d4c5805","fromSide":"top","toNode":"6bb9a144474fc0ce","toSide":"bottom","color":"4"},
		{"id":"3ccae197ecf2ee1e","fromNode":"c74b20207d4c5805","fromSide":"top","toNode":"4729e97a348bea4e","toSide":"bottom","color":"4"},
		{"id":"5f574c251073f112","fromNode":"6bb9a144474fc0ce","fromSide":"right","toNode":"e13299690518c8b3","toSide":"top"},
		{"id":"a9847f1565f1a0dd","fromNode":"f47c3bd63d7bcf62","fromSide":"left","toNode":"e13299690518c8b3","toSide":"right"},
		{"id":"5036af6a89114566","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"f47c3bd63d7bcf62","toSide":"right","label":"1"},
		{"id":"2c2b6cf74d00f89a","fromNode":"f47c3bd63d7bcf62","fromSide":"left","toNode":"4764d7f5736a45a7","toSide":"right","label":"1"},
		{"id":"0ec8f29923bd6442","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"d72c9d39b7812473","toSide":"right"},
		{"id":"ea3611cc25970150","fromNode":"d72c9d39b7812473","fromSide":"left","toNode":"91b9b9ae30398e80","toSide":"right"},
		{"id":"45cfad35100868f8","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"94550d673743ef6b","toSide":"right","label":"2"},
		{"id":"37806d4605cca33f","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"71275df768c5c3df","toSide":"right","label":"3"},
		{"id":"476f5a0bb3d9ee89","fromNode":"94550d673743ef6b","fromSide":"left","toNode":"335a3d359cf51a01","toSide":"right","label":"2"},
		{"id":"7abc1b67363c6c95","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"6febd5d87e7d459c","toSide":"right"},
		{"id":"0e6307dc5adda628","fromNode":"71275df768c5c3df","fromSide":"left","toNode":"3ed26694ed753271","toSide":"right","label":"3"},
		{"id":"397463ba2b7a2a6c","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"53cdcf30d331c445","toSide":"right","label":"4"},
		{"id":"8b60c703cbf60269","fromNode":"53cdcf30d331c445","fromSide":"left","toNode":"0966f6e5949f177e","toSide":"right","label":"4"},
		{"id":"b25cafe828e216c4","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"c9a1855a5b31a55e","toSide":"right","label":"5"},
		{"id":"30b6ffd3dbf3085e","fromNode":"c9a1855a5b31a55e","fromSide":"left","toNode":"c8e2ac1938f361c0","toSide":"right","label":"5"}
	]
}