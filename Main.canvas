{
	"nodes":[
		{"id":"327b3cf255250ad1","type":"group","x":-306,"y":35,"width":290,"height":325,"color":"1","label":"1st Priority"},
		{"id":"0e90979747a6c25b","type":"text","text":"## 7.what is peephole optimization","x":-2720,"y":-102,"width":360,"height":102},
		{"id":"7ce178630f99baae","type":"text","text":"## 8.what is basic blocks and flow graph","x":-2720,"y":400,"width":360,"height":160},
		{"id":"734af23ea7653198","type":"text","text":"9.What are design issues in code generator","x":-2720,"y":920,"width":309,"height":86},
		{"id":"62c28d79a8202e78","type":"file","file":"PDFs/unit-1-notess.pdf","x":1000,"y":-990,"width":400,"height":400},
		{"id":"0717a62c6bd43a5e","type":"text","text":"OS","x":-286,"y":160,"width":250,"height":60},
		{"id":"352f46086bea4476","type":"text","text":"SNLP","x":-286,"y":280,"width":250,"height":60,"color":"2"},
		{"id":"d6a07453d635f1f9","type":"text","text":"AI","x":-8,"y":55,"width":250,"height":60},
		{"id":"526ca694044b1cfe","type":"text","text":"WIT","x":-8,"y":160,"width":250,"height":60},
		{"id":"6503f9fdad76969c","type":"text","text":"ML for DS","x":-8,"y":280,"width":250,"height":60,"color":"#1523e5"},
		{"id":"30debd7ff6db2ade","type":"file","file":"Important question for Tutorial 3 1.docx","x":242,"y":560,"width":230,"height":165},
		{"id":"6a68466816480075","type":"text","text":"## 2. Discuss the concept of bagging and boosting in ensemble learning. How do they address the problem of overfitting?\n\nBagging and boosting are both ensemble learning techniques used to improve the performance of machine learning models by combining multiple weak learners.\n\nBagging, which stands for Bootstrap Aggregating, involves training multiple models on different subsets of the training data, where each subset is sampled with replacement. The final prediction is then made by averaging the predictions of all the models (for regression) or taking a majority vote (for classification). Bagging helps to reduce variance and overfitting by averaging out the predictions of multiple models trained on different subsets of data, thereby making the overall prediction more robust.\n\nBoosting, on the other hand, involves training a sequence of weak learners sequentially, where each subsequent learner focuses on the examples that were misclassified by the previous ones. The final prediction is made by combining the predictions of all the weak learners, typically using a weighted sum. Boosting iteratively improves the model's performance by giving more weight to the examples that are harder to classify correctly, thereby reducing bias and improving generalization.","x":1540,"y":760,"width":595,"height":640,"color":"5"},
		{"id":"846aafdf8311d65c","type":"text","text":"\n\n## Important question for Tutorial\n\n1.      What is linear classification? Explain the concept of decision boundaries and how they relate to linear classifiers.\n\n2.      Discuss the concept of bagging and boosting in ensemble learning. How do they address the problem of overfitting?\n\n3.      What are ensemble classifiers, and how do they differ from individual classifiers? Provide examples of popular ensemble methods.\n\n4.      What is model selection, and why is it important in machine learning? Describe at least two common techniques for model selection.\n\n5.      Define cross-validation and explain why it is used in machine learning. Describe at least two popular methods of cross-validation.\n\n6.      What is probabilistic modeling in the context of machine learning? How does it differ from deterministic modeling?\n\n7.      Discuss at least two common probabilistic models used in machine learning. What are their strengths and weaknesses?\n\n8.      Define topic modeling and discuss its applications in natural language processing (NLP). How does probabilistic inference play a role in topic modeling algorithms such as Latent Dirichlet Allocation (LDA)?\n\n9.      Describe at least two machine learning algorithms commonly used for predicting preterm birth. How do these algorithms utilize probabilistic modeling principles?\n\n10.  Compare and contrast machine learning and statistics. How do they differ in their goals, methodologies, and applications?","x":104,"y":820,"width":507,"height":940},
		{"id":"2301a70f23ace21f","type":"text","text":"Peephole optimization is a technique used in compiler optimization where a small window or \"peephole\" of code is examined and transformed to improve the efficiency of the generated code. This optimization technique focuses on identifying and replacing specific patterns or sequences of instructions with more efficient equivalents.\n\nIn peephole optimization, the compiler looks for patterns of code within a limited number of consecutive instructions, typically within a few instructions of each other. It analyzes these patterns and applies transformations to eliminate redundant or inefficient code sequences.\n\nCommon optimizations performed using peephole optimization include constant folding (replacing arithmetic operations with their constant results), redundant code elimination (removing unnecessary instructions), and instruction combining (replacing multiple instructions with equivalent, more efficient ones\n\n![[Pasted image 20240220173401.png]]","x":-3980,"y":-120,"width":940,"height":480},
		{"id":"044e7f6edf2e7810","type":"text","text":"Basic Blocks: Basic blocks are sequential sequences of code in a program with only one entry point and one exit point. In other words, a basic block is a straight-line code sequence with no branches in except at the entry and no branches out except at the exit. Basic blocks are fundamental building blocks used in control flow analysis and optimization techniques within compilers.\n\nA basic block typically starts with a leader instruction and ends with a terminator instruction, such as a jump or branch. The leader instruction is the first instruction of a basic block, and it's usually the target of a branch or the first instruction in the program. The terminator instruction is the last instruction of a basic block, and it transfers control to another basic block or exits the current block.\n\nBasic blocks simplify control flow analysis by breaking down complex code into smaller, manageable chunks. They serve as the foundation for various compiler optimizations, such as code motion, dead code elimination, and register allocation.\n\n\n\nFlow Graph: A flow graph is a graphical representation of the control flow of a program, depicting the relationships between basic blocks and the control transfers between them. In a flow graph, nodes represent basic blocks, and directed edges represent control flow between these blocks.\n\nThe flow graph provides a visual depiction of how a program's execution flows from one basic block to another. It helps compilers and programmers understand the structure of the program and identify opportunities for optimization.\n\n![[Pasted image 20240220181005.png]]","x":-3980,"y":400,"width":940,"height":560},
		{"id":"2767653a890b41b6","type":"text","text":"1. **Target Machine Selection**: Choosing the target instructions or intermediate representation suitable for the target architecture to efficiently translate high-level language constructs into machine code.\n\n2. **Register Management**: Allocating and assigning registers effectively to minimize register pressure and optimize the usage of limited hardware resources.\n\n3. **Instruction Selection**: Deciding which machine instructions or sequences of instructions best represent high-level language constructs while considering performance and code size trade-offs.\n\n4. **Optimization Strategy**: Implementing optimization techniques such as constant folding, dead code elimination, and instruction scheduling to improve the efficiency and performance of the generated code.","x":-3980,"y":1040,"width":980,"height":240},
		{"id":"d878113263c029ee","type":"text","text":"## 1. What is linear classification? Explain the concept of decision boundaries and how they relate to linear classifiers.\n\nLinear classification is a technique in machine learning used to **classify** data into different categories **based on linear decision boundarie**s.\n\nDecision boundaries are the dividing lines or surfaces that **separate different classes** in a dataset. In linear classification, these **decision boundaries are linear**, meaning they can be represented by straight lines or planes in the feature space.\n\nLinear classifiers **aim to find the optimal linear decision boundary** that best separates the data points into their respective classes.","x":810,"y":760,"width":595,"height":380,"color":"1"},
		{"id":"b003619e0e21bf7a","type":"link","url":"https://www.youtube.com/watch?v=tkSsh91ehUA","x":-4818,"y":510,"width":738,"height":330},
		{"id":"3e15db081918578e","type":"link","url":"https://www.youtube.com/watch?v=clb4tnEm8l4","x":-4818,"y":-17,"width":738,"height":297},
		{"id":"4764d7f5736a45a7","type":"file","file":"Syntax Directed Translation and Definition. GPT + Research.md","x":-3980,"y":-1980,"width":600,"height":576},
		{"id":"f47c3bd63d7bcf62","type":"text","text":"# 1.What is syntax Directed definition and syntax directed translation with examples\n","x":-3323,"y":-2279,"width":403,"height":239,"color":"4"},
		{"id":"e13299690518c8b3","type":"text","text":"## PDF\n\n1.What is syntax Directed definition\n\n![[Pasted image 20240217203727.png]]\n\n\nand syntax directed translation \n![[Pasted image 20240217203958.png]]\n\nwith examples ...\n","x":-4160,"y":-2876,"width":625,"height":621},
		{"id":"91c34134f0cff4bd","type":"text","text":"babhfoiuhbaovifndb","x":-4324,"y":-1378,"width":250,"height":60},
		{"id":"335a3d359cf51a01","type":"text","text":"A syntax tree, also known as a parse tree, is a hierarchical representation of the syntactic structure of a program or expression according to its grammar rules. It visually depicts how the input code is parsed and organized based on its grammar.\n\nIn a syntax tree:\n\n- Nodes represent language constructs such as expressions, statements, or operators.\n- Edges represent relationships between these constructs, typically indicating parent-child relationships.\n\nFor example, consider the expression \"3 * (2 + 4)\" represented as a syntax tree:\n\n```\n      *\n     / \\\n    3   +\n       / \\\n      2   4\n```\n\nParameter passing refers to the mechanism by which arguments are passed to functions or procedures during invocation. There are several methods of parameter passing, including:\n\n1. **Pass by Value**: Copies the value of the actual parameter into the formal parameter. Changes made to the formal parameter do not affect the actual parameter. Example:\n\n```C\nvoid square(int x) {\n    x = x * x;  // Changes to x do not affect the original value outside the function\n}\nint main() {\n    int num = 5;\n    square(num); // num is passed by value\n    // num is still 5 after the function call\n    return 0;\n}\n```\n\n2. **Pass by Reference**: Passes a reference (memory address) of the actual parameter to the formal parameter. Changes made to the formal parameter affect the actual parameter. Example:\n\n```C++\nvoid increment(int& x) {\n    x++;  // Changes to x affect the original value outside the function\n}\nint main() {\n    int num = 5;\n    increment(num); // num is passed by reference\n    // num is now 6 after the function call\n    return 0;\n}\n```\n\n3. **Pass by Pointer**: Passes the address of the actual parameter using pointers. Similar to pass by reference, changes made to the formal parameter affect the actual parameter. Example:\n\n```C++\nvoid decrement(int* x) {\n    (*x)--;  // Changes to *x affect the original value outside the function\n}\nint main() {\n    int num = 5;\n    decrement(&num); // Address of num is passed\n    // num is now 4 after the function call\n    return 0;\n}\n```\n\nSyntax trees are useful in understanding how parameters are passed and manipulated within a program, as they provide a visual representation of the program's structure and execution flow.","x":-3440,"y":-1582,"width":720,"height":502},
		{"id":"94550d673743ef6b","type":"text","text":"# 2.Write a short note on  syntax tree, parameter passing with examples","x":-2603,"y":-1240,"width":383,"height":160,"color":"4"},
		{"id":"71275df768c5c3df","type":"text","text":"# 3.Give syenthesized attribute,and inherited attribute,L-attribute  give example.","x":-2360,"y":-620,"width":274,"height":220,"color":"4"},
		{"id":"4729e97a348bea4e","type":"file","file":"PDFs/compiler Design COUNTIU=NUE unit 4.5.pdf","x":-2200,"y":-1879,"width":1109,"height":639,"color":"4"},
		{"id":"b703527f4d45587a","type":"file","file":"PDFs/CSM SYLLABUS.pdf","x":280,"y":-2480,"width":868,"height":1000},
		{"id":"6bb9a144474fc0ce","type":"file","file":"PDFs/compiler design notes1,2,3,4.pdf","x":-1020,"y":-1840,"width":1157,"height":560,"color":"4"},
		{"id":"0966f6e5949f177e","type":"text","text":"## 6.Give annotated parse tree and 3-address  code","x":-2720,"y":-305,"width":360,"height":145},
		{"id":"c0ca81992ad252a0","type":"text","text":"1.What is syntax Directed definition and syntax directed translation with examples\n\n2.write a short note on  syntax tree, parameter passing with examples\n\n3.Give syenthesized attribute,and inherited attribute,L-attribute  give\n\nexample.\n\n4.Take one  SDT  and generate parese tree for one string\n\n5.What is type checking,switch statement\n\n6.Give annotated parse tree and 3-address  code\n\n7.what is peephole optimization\n\n8.what is basic blocks and flow graph\n\n9.What are design issues in code generator\n\n10.what is storage organization","x":-1580,"y":-590,"width":651,"height":502,"color":"4"},
		{"id":"91b9b9ae30398e80","type":"text","text":"Moiz","x":-1700,"y":460,"width":300,"height":100},
		{"id":"11002d409535b6f6","type":"file","file":"cd imp 2.5.docx","x":-1355,"y":45,"width":200,"height":80,"color":"4"},
		{"id":"d72c9d39b7812473","type":"text","text":"10. what is storage organization","x":-1680,"y":300,"width":260,"height":100},
		{"id":"c74b20207d4c5805","type":"text","text":"CD","x":-286,"y":55,"width":250,"height":60,"color":"4"},
		{"id":"24a5e7f6bafdfc39","type":"file","file":"Images/WhatsApp Image 2024-02-15 at 13.05.21_b2b8aeb6.jpg","x":-880,"y":460,"width":484,"height":860},
		{"id":"da72bfe674c9a687","type":"text","text":"Annotated Parse Tree: An annotated parse tree is a hierarchical representation of the syntactic structure of a program's source code. It demonstrates how the grammar rules are applied during the parsing process. Each node in the tree corresponds to a grammar rule or a token in the input code, and it may carry additional information, such as the type of the token or the value it holds.\n\n3-Address Code: 3-address code is a low-level representation of code that simplifies complex expressions into a series of simple instructions. Each instruction typically operates on two operands and produces a result that is stored in a temporary variable. This form of code is often used as an intermediate representation in compilers before further optimization or translation to machine code.\n\nNow, let's consider an example expression: `a = b * (c + d)`\n\nAnnotated Parse Tree:\n```\n         =\n       /   \\\n      a    *\n          / \\\n         b   +\n            / \\\n           c   d\n```\nExplanation: Here, the annotated parse tree shows the assignment operation where the variable 'a' is assigned the result of the multiplication operation. The multiplication operation itself involves the variable 'b' and the addition operation. The addition operation involves variables 'c' and 'd'.\n\n3-Address Code:\n```\n1. t1 = c + d\n2. t2 = b * t1\n3. a = t2\n```\nExplanation: The 3-address code breaks down the expression into simple instructions. First, it computes the sum of 'c' and 'd' and stores the result in temporary variable 't1'. Then, it multiplies 'b' with 't1' and stores the result in temporary variable 't2'. Finally, it assigns the value of 't2' to 'a'.[https://www.youtube.com/watch?v=c0RZP-e9Hsw]()","x":-3980,"y":-540,"width":940,"height":380},
		{"id":"2035a940e97eda8a","type":"link","url":"https://www.youtube.com/watch?v=c0RZP-e9Hsw","x":-4960,"y":-480,"width":720,"height":280}
	],
	"edges":[
		{"id":"47fde9acda44a61a","fromNode":"352f46086bea4476","fromSide":"bottom","toNode":"24a5e7f6bafdfc39","toSide":"top","color":"2"},
		{"id":"e6d63f9c1029db5e","fromNode":"30debd7ff6db2ade","fromSide":"bottom","toNode":"846aafdf8311d65c","toSide":"top"},
		{"id":"84f6269a08c6bcc9","fromNode":"6503f9fdad76969c","fromSide":"bottom","toNode":"30debd7ff6db2ade","toSide":"top","color":"#192296"},
		{"id":"229bff6a6daf0b71","fromNode":"d6a07453d635f1f9","fromSide":"right","toNode":"62c28d79a8202e78","toSide":"left"},
		{"id":"da5abb483f604ebc","fromNode":"846aafdf8311d65c","fromSide":"right","toNode":"d878113263c029ee","toSide":"left"},
		{"id":"2a0b0c042e52f5e9","fromNode":"846aafdf8311d65c","fromSide":"right","toNode":"6a68466816480075","toSide":"left"},
		{"id":"7edc2c1cf81f95a8","fromNode":"11002d409535b6f6","fromSide":"top","toNode":"c0ca81992ad252a0","toSide":"bottom","color":"4"},
		{"id":"cf30db9b8e02cd19","fromNode":"c74b20207d4c5805","fromSide":"left","toNode":"11002d409535b6f6","toSide":"right","color":"4"},
		{"id":"cb9d16a29157456f","fromNode":"c74b20207d4c5805","fromSide":"top","toNode":"6bb9a144474fc0ce","toSide":"bottom","color":"4"},
		{"id":"3ccae197ecf2ee1e","fromNode":"c74b20207d4c5805","fromSide":"top","toNode":"4729e97a348bea4e","toSide":"bottom","color":"4"},
		{"id":"5f574c251073f112","fromNode":"6bb9a144474fc0ce","fromSide":"right","toNode":"e13299690518c8b3","toSide":"top"},
		{"id":"a9847f1565f1a0dd","fromNode":"f47c3bd63d7bcf62","fromSide":"left","toNode":"e13299690518c8b3","toSide":"right"},
		{"id":"5036af6a89114566","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"f47c3bd63d7bcf62","toSide":"right"},
		{"id":"2c2b6cf74d00f89a","fromNode":"f47c3bd63d7bcf62","fromSide":"left","toNode":"4764d7f5736a45a7","toSide":"right"},
		{"id":"0ec8f29923bd6442","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"d72c9d39b7812473","toSide":"right"},
		{"id":"ea3611cc25970150","fromNode":"d72c9d39b7812473","fromSide":"left","toNode":"91b9b9ae30398e80","toSide":"right"},
		{"id":"45cfad35100868f8","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"94550d673743ef6b","toSide":"right"},
		{"id":"37806d4605cca33f","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"71275df768c5c3df","toSide":"right"},
		{"id":"476f5a0bb3d9ee89","fromNode":"94550d673743ef6b","fromSide":"left","toNode":"335a3d359cf51a01","toSide":"right"},
		{"id":"8b10a874d01c153f","fromNode":"c0ca81992ad252a0","fromSide":"left","toNode":"0966f6e5949f177e","toSide":"right","label":"6"},
		{"id":"9e961ba0d927a8f1","fromNode":"0966f6e5949f177e","fromSide":"left","toNode":"da72bfe674c9a687","toSide":"right"},
		{"id":"4d1cb73fd566ec03","fromNode":"0e90979747a6c25b","fromSide":"left","toNode":"2301a70f23ace21f","toSide":"right"},
		{"id":"fc4bcdedf147334c","fromNode":"0e90979747a6c25b","fromSide":"right","toNode":"c0ca81992ad252a0","toSide":"left","label":"7"},
		{"id":"e742dd774ca6f69f","fromNode":"7ce178630f99baae","fromSide":"left","toNode":"044e7f6edf2e7810","toSide":"right"},
		{"id":"a49ef62fdb7103b4","fromNode":"7ce178630f99baae","fromSide":"right","toNode":"c0ca81992ad252a0","toSide":"left","label":"8"},
		{"id":"56f655e74bd44912","fromNode":"734af23ea7653198","fromSide":"left","toNode":"2767653a890b41b6","toSide":"right"},
		{"id":"7db74fa8d71884aa","fromNode":"734af23ea7653198","fromSide":"right","toNode":"c0ca81992ad252a0","toSide":"left","label":"9"},
		{"id":"7a4bf784e4550288","fromNode":"da72bfe674c9a687","fromSide":"left","toNode":"2035a940e97eda8a","toSide":"right"},
		{"id":"bcb50854e6b904d1","fromNode":"044e7f6edf2e7810","fromSide":"left","toNode":"b003619e0e21bf7a","toSide":"right"},
		{"id":"5368db11e4c8cca4","fromNode":"2301a70f23ace21f","fromSide":"left","toNode":"3e15db081918578e","toSide":"right"}
	]
}