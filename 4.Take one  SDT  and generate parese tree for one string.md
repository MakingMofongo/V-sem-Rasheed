Let's consider a simple syntax-directed translation (SDT) example for arithmetic expressions. We'll define an SDT that generates a parse tree for an expression.

Grammar:
```
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```

Syntax-Directed Translation:
```
E -> E1 + T { E.value = E1.value + T.value; }
   | T { E.value = T.value; }
T -> T1 * F { T.value = T1.value * F.value; }
   | F { T.value = F.value; }
F -> (E) { F.value = E.value; }
   | id { F.value = id.value; }
```

Let's generate a parse tree for the expression "2+3*4" using the SDT:

1. Tokenize the expression:
```r
2  +  3  *  4
```

2. Apply the SDT rules to construct the parse tree:

![[Pasted image 20240220202413.png|300]]
In this parse tree:
1. All leaf nodes need to be terminals.
2. All interior nodes need to be non-terminals.
3. In-order traversal gives the original input string.